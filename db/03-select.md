# Комманды SQL

Они не регистро-зависимые. То есть можно писать как `upper`, `UPPER`, `SelECt` (хоть каждую букву в другом регистре).

## `SELECT`
Результат выполнения `SELECT` - таблица.
```sql
select "any string" /* выбрать литерал */
select * from peoples /* выбрать все */
select name, surname from peoples /* выбрать конеретные поля */
select work_address as address, surname from peoples
/* as address - перименование (псевдоним) */
```

## Литералы
- Значения фиксированного типа
### `String`
- строковый: в двойных либо одинарных кавычках, есть экранирование как в Си
### Числовой
- любое рациональное число.
Примеры: 1.2, 1, 0, -0.01, 1e3, +100 и пр.

Есть арифметические операции:
% или `MOD`, *, +, -, / (обычное деление), `DIV` (целочисленное деление)
```sql
select -11 * (1e2 - 13) / 33 as Result
```

### Литерал даты и времени
для взаимодействия с программистом они могут быть представленны как строки:

Дата: `YYYY-MM-DD`, `YYYYMMDD`
Время: `hh:mm:ss`, `hh:mm`, `hh`, `ss` - тоже можно опустить разделитель, если можно
Дата и время: `YYYY-MM-DD hh:mm:ss`, `YYYYMMDDhhmmss`

### Логический
`true` либо `false` (`TRUE` либо `FALSE`) - при получении из таблицы конвертируются в понятно какие числа

### NULL
обозначение отсутствия значения

## DISTINCT
```sql
select distinct fields... from SomeTable
```

Если перечислить несколько полей, то одинаковыми считать они будут как `tuple`. То есть тогда допустимы повторы в каком-то из полей, но не всех сразу.

## WHERE
```sql
select field from SomeTable where condition1 and condition2 ...
```

Сравнение на равенство - как в математике, просто `=`. Больше, меньше и пр. - как обычно.

`<=>` - то же самое, что и `=`, только работает с `NULL`: `NULL` равен `NULL`, но не равен любому другму значению.

`<>` и `!=` - обозначение для "не равно"

Логические операции: `XOR`, `OR`, `AND`, `NOT`.

Если поле само по себе boolean, то его можно сразу использовать как условие

## LIKE
Для того, чтобы проверить, соответствует ли строка regexp, можно использовать оператор like. 

Но regexp ограниченный: только `%` и `_` - соответственно любая последовательность и любой символ

```sql
select * from SomeTable where middle_name like "@ Surname"
```

Чтобы можно было экранировать символы, нужно использовать специальный оператор `ESCAPE`:
```sql
select * from SomeTable where middle_name like "% !%!%!%" escape "!" 
```
В примере выше, `!` назначен как символ экранирования (вместо бекслеша).

## ORDER BY
По-умолчанию, строки таблицы приходят в неопределенном порядке. Чтобы их упорядочить, нужен этот опреатор

```sql
select ... from ...
where ...
order by field_1 [asc|desc] [, field_i [asc|desc]]
```

asc - ascending, desc - descending

Для строк - лексикографически, для остального - понятно как

При перечислении нескольких столбцов, порядок лексикографический


## GROUP BY
Группировка значений по определенному полю.
```sql
select group_field, "literal" from SomeTable
group by group_field
```
Так как остальные поля могут быть разными у разных записей в группе, их нельзя вывести.

Можно также вывести значения, посчитанные агрегатными функциями.
```sql
select group_field, avg(some_sum) from SomeTable
group by group_field
```

Значения NULL трактуются как равные в `group by`.

### Агрегатные функции
- применяются для множества значений (не зависят от порядка применения)

`sum(field)`, `avg(field)`, `count(field)`, `min(field)`, `max(field)`

Все функции выше - считают только не-`null` значения. (иначе не понятно, зачем `count`'у указывать поле)

Исключение - `count(*)` - просто считает размер группы

Пример:
```sql
select home_type, count(*) as amount from rooms
  group by home_type
  order by amount desc
```

Результат:
|home_type|amount|
|-|-|
|Private room | 28|
|Entire home/apt| 21|
|Shared room | 1|

## HAVING
- аналог `where` для групп (по полученным результатам для группы)

![alt text](images/select_structure.png)

Общая структура запроса со всем:
```sql
select [константы, агрегатные_функции, поля_группировки]
from имя_таблицы
where условия_на_ограничения_строк
group by поля_группировки
having условие_на_ограничение_строк_после_группировки
order by условие_сортировки
```




