# Асинхронность в C#, .NET

## Предпосылки
Один процессор (один поток) может выполнять только одну задачу в один момент времени. Но задач всегда намного больше, чем потоков.

Процесс = несколько потоков (память - одна на все потоки)

Виды нагрузки:
- CPU-bounded
- IO-bounded

Раньше (устаревшее API для асинхронности): 
```cs
public IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object? state);

public void EndWrite(IAsyncResult asyncResult);
```

Теперь: `Task`, `Task<T>` (корутина и прочие названия)
Временно было:
```cs
socket.ConnectAsync(...).ContinueWith(
    (_, _) => { ... }
);
```

Сейчас (фактически аналогичен коду выше):
```cs
await socket.ConnectAsync(...);
...
```

Операция должна быть помечена `async`, вызов должен использовать `await`. Должен возвращаться \*Task\*.

Код будет преобразован в state-машину.

Если не писать `await`: операция выполнится, но мы не будем ее дожидаться. Что тут подразумевается: есть `TheradPool`, из которого берутся потоки. Если мы не дожидаемся операции, то она будет выполняться в одном из этих потоков.

Когда пишется `await`, то происходит следующее: текущий поток отправляется в пулл потоков, когда операция завершается, берется поток из пулла (возможно другой).

Если не писать `await`, то вылетать будет AggregateException, InnerException которого есть то исключение, которое на самом деле вылетело. То есть исключения, которые бросаются в асинхронном коде, сохраняются в Task и потом уже выбрасываются.

`ValueTask`, `ValueTask<T>` - оптимизация, не выделяется в куче; value тип. Если асинхронный метод может не выделять память (хотя бы в одном из путей исполнения) - то следует воспользоваться `ValueTask`.

Параллельное выполнение асинхронных запросов:
```cs
var taskWithResult = DoAsync0();
Task[] tasks = [
    taskWithResult,
    DoAsync1();
    DoAsync2();
    DoAsync3();
    DoAsync4();
];
// Ждем всех:
await Task.WhenAll(tasks);
var result = await taskWithResult;

// Ждем первого попавшегося:
var firstTask = await Task.WhenAny(tasks);
var result = await firstTask;
```

## Cancellation
- есть веб приложение, и мы закрываем браузер. Запрос ресурсоемкий, и мы хотим его отменить.







