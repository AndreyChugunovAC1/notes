# Multithreading

Раньше были *однозадачные системы*.
* &#10060; Пока задача не завершится, все ждут
* &#10060; Монополия на память и i/o
* &#10060; Простой ресурсов, долгое время отклика

Потом пакетные программы. Концепция пакета: набор заданий для исполнения. (1950-е)
* &#9989; i/o - реализуется переключением
* &#9989; Память - разделяемая, изолированная.
* &#10060; Простой ресурсов, долгое время отклика

Многозадачные системы. (1960-е)
* &#9989; Память - разделяемая, изолированная.
* &#9989; Переключение задач - прерывание
* &#9989; i/o - разделяемый
* &#9989; Уменьшенное время отклика

Многопоточные программы. Многозадачные системы + параллелизм внутри одной задачи. (1990-е)

**Пример:** игра, у нее есть цикл отрисовки
* Ждать ввода пользователя
* Считать (физику и пр.)
* Рендерить

Ввод пользователя затормаживает просчет физики.

Идея решения: разделить на несколько потоков. Есть **состояние**. Считатель пишет в него, рендер читает. Но остается проблема: отрисовка некорректного (недосчитанного) состояния.

*Многопоточность - всегда усложнение программы.*

## Многопоточное программирование

Программа имеет несколько потоков, которые умеют друг с другом взаимодействовать.
* Синхронизация
* Обмен сообщения

## Итеративный параллелизм:
```java
/* shared */ double[][] a, b, c;
for (int i = 0; i < n; i++) { // parallel
  for (int j = 0; i < n; i++) { // parallel
    c[i][j] = 0;
    for (int t = 0; t < n; t++) {
      c[i][j] += a[i][t] * b[t][j];
    }
  }
}
```
**Пример плохого распараллеливания:**
```java
worker[i] {
  double[] a; // a[i][...]
  double[][] b; // b[...][...]
  double[] c; // c[i][...]
  // recieve a, b from coordinator
  for (int j = 0; j < n; j++) {
    c[j] = 0;
    for (int k = 0; k < n; k++) {
      c[j] += a[k] * b[k][j];
    }
  }
  // send c to coordinator
}
```

**Проблемы:**
* Накладные расходы - лишнее копирования
* $n$ потоков, нужно передать $n^2$ значений для b - суммарно $n^3$ то есть параллельность сделала только хуже

**Более аккуратное решение:**
```java
worker[i] {
  double[] a; // a[i][...]
  double[] b; // b[...][i]
  double[] c; // c[i][...]
  // recieve a, b from coordinator
  for (int j = 0; j < n; j++) {
    // counting c[(i - j + n) % n]
    // (1) send b to worker[(i + 1) % n];
    // (2) receive b from worker[(i + n - 1) % n];
  }
  // send c to coordinator
}
```

Тот же $n^3$ данных, но уже параллельно.

Что если поменять (1) и (2)? Ничего работать не будет вовсе (все будут ждать ресурсы).

## Рекурсивный параллелизм
**Вычисление интеграла:**
```java
double integrate(double l, double r) {
  double m = (l + r) / 2;
  double curArea = area(l, m) + area(m, r);

  if (abs(curArea - area(l, r)) > ε) {
    return integrate(l, m) + integrate(m, r);
  } else {
    return curArea;
  }
}
double area(double l, double r) {
  return (f(l) + f(r)) * (r - l) / 2;
}
```

Конкретно этот код никак не распараллелить *иттеративно*. Но можно рекурсивно:

```java
double integrate(double l, double r) {
  double m = (l + r) / 2;
  double la = area(l, m);
  double ra = area(m, r);

  if (abs(la + ra - area(l, r)) > ε) {
    la = integrate(l, m); // parallel
    ra = integrate(m, r); // parallel
  }
  return la + ra;
}
```

**Обычно вызовы чистых функций можно делать параллельно.**

## Операции для работы с потоками
1) Создание потока
0) Уничтожение потока
0) Неделимая операция `<statement>`
0) Неделимая операция с ожиданием условия (`<await(cond) statement>`)

**Пример:**

**1 версия:**
```java
/* shared */ int max = Integer.MIN_VALUE;
worker[i] {
  if (max < a[i])
    // (*) вот здесь проблема, несолько потоков могут зайти в if
    max = a[i];
}
```

**2 версия:**
```java
/* shared */ int max = Integer.MIN_VALUE;
worker[i] {
  неделимо {
    if (max < a[i])
      max = a[i];
  }
}
```
По факту не многопоточная.

**3 версия:**
```java
/* shared */ int max = Integer.MIN_VALUE;
worker[i] {
  if (max < a[i])
    неделимо {
      if (max < a[i]) max = a[i];
    }
}
```
Спекулятивное исполнение - оптимизация параллелизма, которая может сработать а может нет. То есть это версия 2, которая иногда работает быстрее.

## Планировщик
Породили много потоков. Планировщик решает кто что и когда будет исполнять.

**Типы многозадачности:**
* *Кооперативная* - процесс решает, что ему не нужны ресурсы и освобождает процессор. То есть пока исполняемый процесс не сообщит о том, что он может отдохнуть (например чтение из файла), **все** остальные процессы будут ждать (довольно жесткое условие)
* *Вытесняющая* все процессы так или иначе исполняются, вытесняя друг друга - требует очень аккуратной расстановки неделимой операции

**Безопасность** - любое исполнение должно удовлетворять правилам планировщика (например, неделимость определенных операций).

**Живучесть** - если есть поток, который может исполняться, он будет исполняться. Должен быть *прогресс*.

**Справедливость**
* Безусловная (нет условий) - каждый поток будет исполняться (получит вычислительные ресурсы для исполнения)
* Слабая ?
* Сильная ?

## В java
`Thread` - поток выполнения (+ операции с ними). Интерфейс `Runnable` - то что можно запустить (`public void run()`) - не бросает исключений.

```java
Thread t = new Thread(() -> {
  System.out.println("Hello");
});
t.start();
```

Старый способ (не делать так):
```java
Thread t = new Thread(){
  public void run() {
    System.out.println("Hello");
  }
});
t.start();
```

### Состояния потока
`thread.getState()`, `thread.isAlive()`.

|getState()|isAlive()|
|-|-|
|NEW||
|RUNNABLE|+|
|BLOCKED|+|
|WAITING|+|
|TIMED_WAITING|+|
|TERMINATED||





