# Anonymous functions

Можно написать так (аналогично в случае предикатов):
```cpp
struct func_struct {
   bool operator()(T a, T b) const {...}
};
...
sort(v.begin(), v.end(), func_struct{});
```
* Неудобно поятоянно придумывать названия для такихи мини-структур
* Просто неудобно, boilerplate.

## Lambdas

Сейчас для этого возникло новое обозначение (синтаксический сахар):
```cpp
sort(v.begin(), v.end(), [](T a, T b) -> bool {...})
```

## Контекст замыкания
```cpp
int a, b;
auto l0 = []{}; // () необязательны
auto l1 = [](){};
auto l2 = [](int x){ ... };
auto l3 = [a](){}; // по значению
auto l4 = [&a](){}; // по ссылке
auto l5 = [=](){}; // все по значению
auto l6 = [&](){}; // все по ссылке
auto l7 = [=, &b](){}; // все по значению, b по ссылке
auto l7 = [&, b](){}; // все по ссылке, b по значению
auto lm = [am = move(a)](){}; // перемещаем a
auto ln = [ac = a](){}; // переименование
auto ln2 = [&ar = a](){}; // переименование ссылки
auto lg = [...](Args... args) -> R {...}
```

`this` захватывается если писать & или =. Чтобы захватить его персонально, можно написать `[this]`.
Также есть `*this`: он подразумевает, что объект будет __скопирован__ внутрь лямбды:
```cpp
[this](){ /* use ref */ };
[*this](){ /* use copy */ };
```

Лямбда эквивалентна следующему классу:
```cpp
auto l = [a, &b, /* ... */](Args...) -> R {};
// <=>
class __WeirdInternalName  {
  T a; 
  T& b;
  // ...
public:
  R operator()(Args...) const {
    // ...
  }
};
```

__Куча фактов про лямбды:__
1) Если хочется уметь менять переменные из контекста, можно написать `[...]() mutable {}`. По умолчанию так делать нельзя (обратить внимание на `const` в коде выше) .
2) Шаблоны (именно для operator() - для самого класса это бесполезно, он создается 1 раз): `[]<typename T>(T x){}`
3) _Вместо тысячи шаблонов_: `[](auto x){}`
4) Лямбды __с пустым контекстом__ (_pure_) умеют конвертироваться к указателю (поняно, почему только с пустым). Можно использовать унарный `+`:
`R (*pf)(...) = +[](...) -> R {};`
5) Лямбды умеют копироваться и муваться (если соответствующее умеют делать все поля)
6) У лямбды допустим модификатор `static`. Такая лямбда не может захватывать `this` или обращаться к нестатическим членам класса.
7) У каждой лямбды уникальный тип и эти типы не умеют конвертироваться друг в друга - это нужно для статического полиморфизма.

## Лямбда против указателя
```cpp
bool cmp(int a, int b) { return a > b; }
sort(v.begin(), v.end(), &cmp);
// медленнее, чем:
sort(v.begin(), v.end(), [](int a, int b) { return a > b; });
// либо
sort(v.begin(), v.end(), greater<int>());
```
Причина: инлайнинг объекта лямбды или (что то же самое) объекта класса (`greater`) - компилятор знает конкретно какую функцию вызывать и может ее заинлайнить (сразу мнемонику `cmp` поместить на месте).
В первом же случае `sort` берет указатель и переходит по нему чтобы добраться до функции - он не знает наперед что передадут.

__Всякое по этому поводу:__
* Есть `-flto`, иногда это может помочь. Но гарантий нет, например, если надо инлайнить дважды, может не сработать.
* -O3 здесь сработает лучше, будут заинлайнены часные случаи.

## Статический и динамический полиморфизм
```cpp
void call_dynamic(void (*f)()) { f(); }
void call_static(auto f) { f(); }
```
В первом случае полиморфизм _динамический_: в одну и ту же функцию можно передать любую функцию. Во втором же случае на момент компиляции известно какую именно функцию вызывать, поэтому полиморфизм _статический_ (если передавать объекты с `operator()`).

_Спекулятивная девиртуализация_ - что это, понятно по коду:
```cpp
void call_dynamic(void (*f)()) {
  if (f == specific_function1) {
    specific_function1();
  } else if (f == specific_function2) {
    specific_function2();
  } else {
    f();
  }
}
```
* В целом ускоряет, но понятно, что размер исполняемого файла увеличивается.
* Не всегда понятно когда это хорошо, а когда нет.

## std::function
Нужно:
```cpp
/* ??? */ f = flag ?
  [](int a, int b){ return a < b; } :
  [](int a, int b){ return a > b; };
```
Так сделать нельзя, даже если написать `auto`, так как все лямбды имеют особый тип.
Решение:
```cpp
function<bool(int, int)> f = flag ?
  [](int a, int b){ return a < b; } :
  [](int a, int b){ return a > b; };
```
Как писать `function`:
* Нужен шаблонный конструктор (чтобы принимать и указатель на функцию и любые функциональные объекты)
* Хранить можно как `void*`
* Нужно запоминать тип, чтобы потом его удалять - нужно вызвать деструктор.
* Также нужны операторы копирования и перемещения и тп.
* Можно не все хранить как `void*`, а воспользоваться _rtti_: у базового класса `concept` есть куча наследников (`model<F>`) на каждый тип. В самом `function` хранится указатель на текущего наследника.
Соответственно каждый наследник реализует все нужные операции для соответствующего типа.
* _Small-object optimization_

`function` обязывает объекты уметь копироваться. Так как он может хранить любой тип (почти как `void*`), то (исключительно синтаксически) невозможно проверить что все типы, которые в него могут прийти, могут быть скопированы и в зависимости от этого уже решить есть ли у него оператор копирования. Поэтому отдельно есть `move_only_function`.

### std::any
... - _type-erasure_ обертка общего назначения. Реализует только деструктор, оператор копирования и оператор перемещения.

## (boost::) any_iterator\<iterator_tag\>
... - _type-erasure_ обертка над итератором. Реализует все методы итератора в соответствии с тегом.

Может возникнуть идея сделать итераторы тоже динамически полиморфными (в C++ они всегда шаблонные).
* Бывает нужно для генерализированного кода, например, одна функция `sort` вообще (без шаблонирования).
* Из реддита: _Every step requires `a++` `a!=` and `*a` at least. 3 different "virtual" dispatches burn your performance badly. It is in boost. But I'd usually advise against using it._

## design patter adapter (wrapper)
... - идея общего интерфейса (any_iterator - хороший пример).

Есть библиотека `dyno`, в которой сделан механизм динамического полиморфизма. Пример с их ![гитхаба](https://github.com/ldionne/dyno)
```cpp
DYNO_INTERFACE(Drawable,
  (draw, void (std::ostream&) const)
);

struct Square { // нет наследования!
  void draw(std::ostream& out) const { out << "Square"; }
};

struct Circle { // нет наследования!
  void draw(std::ostream& out) const { out << "Circle"; }
};

// получилась type-erasure обертка:
void f(Drawable const& d) {
  d.draw(std::cout);
}

int main() {
  f(Square{}); // prints Square
  f(Circle{}); // prints Circle
}
```

Фактически, `any_iterator<forward>` это:
```cpp
DYNO_INTERFACE(any_iterator_forward,
  (operator++, ...),
  (operator*, ....),
  ...
);
```