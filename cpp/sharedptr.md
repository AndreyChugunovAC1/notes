# Shared pointer (std::shared_ptr\<T\>)

`shared_ptr` - _smart-pointer_ (как и `unique_ptr`). То есть он ответственнен за удаление объекта.

Примеры применения:
```cpp
shared_ptr<mytype> p1(new mytype(/*  */));
shared_ptr<mytype> p2(p1); // p2 = p1
```
__Структура, версия #1__:
|`ptr`|`cntrl_block_ptr`|
|:-:|:-:|
|`mytype`| `ref_count` |

Он ответственнен за удаление, и решено, что у пользователя есть возможность передать собственный deleter:

__Структура, версия #2__:
|`ptr`|`cntrl_block_ptr`|
|:-:|:-:|
|`mytype`| `ref_count` `deleter`|

Различие с deleter-ом между `unique_ptr` и `shared_ptr` заключается в том, что у `shared_ptr` deleter type-erasure, а у `unique_ptr` он - часть типа (соответственно есть inlining).

В типе у `unique` - это оптимально. У `shared` это сделано специально, чтобы из разных мест программы можно было пользоваться указателем на один и тот же объект, особенно когда невозможно достать тип deleter'а. Еще причина: `make_shared`.

## Aliasing constructor
Странный пример, который не поняно как нормально обобщить:
```cpp
struct spider {
  array<leg, 8> legs;
};

int main() {
  shared_ptr<spider> spi(new spider);
  shared_ptr<leg> spi_leg(spi, &spi->legs[0]);
}
```
По неведомой причине, есть желание, чтобы паук существовал,  если кто-то ссылается на его ногу. Чтобы это реализовать используется _aliasing constructor_. Счетчик ссылок берется у `spi`, но указатель хранится на `spi->legs[0]`. Это работает так, будто бы есть еще одна ссылка на паука, но ссылка идет непосредственно только на ногу.

Так как ссылка на ногу должна уметь удалять самого паука, в `cntrl_block` должен быть и указатель на самого паука.

__Структура, версия #3__:
|`ptr_part`|`cntrl_block_ptr`|
|:-:|:-:|
|`mytype`| `ref_count` `ptr_mytype` `deleter`|

Просто стоит понимать, что `ptr_part` подразумевает что можно ссылаться и на сам `mytype`.

## make_shared
Хранит вместе `cntrl_block` и объект.
```cpp
shared_ptr<mytype> p = make_shared<mytype>(/* ... */);
```
__Плюсы:__
* Делает одну аллокацию
* В большинстве случаев его достаточно и его следует использовать

__Минусы:__
* Нельзя использовать кастомный deleter
* Если использовать `weak_ptr`, он будет мешать удаляться `ctrl_block`'у, который (в силу того, что храниит в себе сам объект) может много весить.

## weak_ptr
* Ссылается на объект, но не мешает его удалению
* Можно превратить в `shared_ptr` (метод `lock()`)
* Проверка что живой `expired()` - но ее не следует использовать в многопоточной программе (его `true` ничего не значит)
* Можно использовать для кэширования.

Отличие `shared_ptr(weak)` от `weak.lock()`: первый бросает исключение `bad_weak_ptr`, если `weak` пустой, `weak.lock()` же просто вернет пустой `shared_ptr`. Обычно лучше `weak.lock()`.


__Структура, версия #4 (final)__:
|`ptr_part`|`cntrl_block_ptr`|
|:-:|:-:|
|`mytype`| `ref_count` `ref_weak_count` `ptr_mytype` `deleter` |

* `ref_count` = 0 значит пора удалять сам объект.
* `ref_count` = `ref_weak_count` = 0 значит пора удалять и `cntrl_block`

__Пример про виджеты _кратко_.__ (см. Herb Sutter)
Есть 2 функции: `load_widget` и `make_widget`.
Создание самого ресурса происходит в `load`. В `make` мы кэшируем и храним `map<int, weak_ptr>`. Однако, если не делать дополнительных усилий, то `map` будет расти _unbounded_. Чтобы иногда все-таки удалять узлы из `map`, можно сделать кастомный deleter, в который передать итератор из `map` и, когда надо, удалять узел. _Чуть подробнее_: лучше не итератор, а обертку, которая умеет немного больше, чем просто итератор. Вывод: пишите на джаве.

## enable_shared_from_this
__Проблема:__ у больного на голову пользователя вознинкло желание вернуть из метода класса `shared_ptr(this)`. Если написать так, то объект может быть удален раньше времени deleter'ом.

__Решение:__
* Не заниматься этой ерундой (так можно всегда, например, пустой кастомный деструктор __кажется__ должен помочь)
* Воспользоваться `enable_shared_from_this`:
```cpp
/* Только public наследование! */
struct mytype : public enable_shared_from_this<mytype> {
  auto not_constructor_nor_destructor() {
    return shared_from_this(); // метод родителя
  }
}
```

Он хранит в себе `weak_ptr`. И `shared_from_this()` возвращает `shared_ptr(weak)`.
